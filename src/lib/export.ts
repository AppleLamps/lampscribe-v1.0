import PDFDocument from 'pdfkit';
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
} from 'docx';

export interface TranscriptData {
  id: string;
  name: string;
  text: string;
  language?: string | null;
  duration?: number | null;
  createdAt: Date;
  segments?: {
    text: string;
    speaker?: string | null;
    startTime: number;
    endTime: number;
  }[];
}

export interface ExportOptions {
  includeTimestamps?: boolean;
  includeSpeakers?: boolean;
  title?: string;
}

/**
 * Format seconds to HH:MM:SS,mmm for SRT format
 */
function formatSrtTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
}

/**
 * Format seconds to MM:SS for display
 */
function formatTimestamp(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Generate plain text export
 */
export function generateTxt(transcript: TranscriptData, options: ExportOptions = {}): string {
  const lines: string[] = [];
  
  // Header
  lines.push(options.title || transcript.name);
  lines.push('='.repeat(50));
  lines.push(`Generated by LampScribe`);
  lines.push(`Date: ${new Date(transcript.createdAt).toLocaleDateString()}`);
  if (transcript.duration) {
    lines.push(`Duration: ${formatTimestamp(transcript.duration)}`);
  }
  lines.push('');
  lines.push('='.repeat(50));
  lines.push('');

  // Content
  if (transcript.segments && transcript.segments.length > 0 && options.includeTimestamps) {
    for (const segment of transcript.segments) {
      const timestamp = `[${formatTimestamp(segment.startTime)}]`;
      const speaker = options.includeSpeakers && segment.speaker ? `${segment.speaker}: ` : '';
      lines.push(`${timestamp} ${speaker}${segment.text}`);
      lines.push('');
    }
  } else {
    lines.push(transcript.text);
  }

  return lines.join('\n');
}

/**
 * Generate SRT subtitle file
 */
export function generateSrt(transcript: TranscriptData): string {
  const lines: string[] = [];
  
  if (transcript.segments && transcript.segments.length > 0) {
    transcript.segments.forEach((segment, index) => {
      lines.push((index + 1).toString());
      lines.push(`${formatSrtTime(segment.startTime)} --> ${formatSrtTime(segment.endTime)}`);
      
      const speaker = segment.speaker ? `[${segment.speaker}] ` : '';
      lines.push(`${speaker}${segment.text}`);
      lines.push('');
    });
  } else {
    // If no segments, create a single subtitle for the entire transcript
    lines.push('1');
    lines.push(`${formatSrtTime(0)} --> ${formatSrtTime(transcript.duration || 60)}`);
    lines.push(transcript.text);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate PDF document
 */
export async function generatePdf(transcript: TranscriptData, options: ExportOptions = {}): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
      });

      const chunks: Buffer[] = [];
      doc.on('data', (chunk) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Title
      doc
        .font('Helvetica-Bold')
        .fontSize(24)
        .fillColor('#1f2937')
        .text(options.title || transcript.name, { align: 'center' });

      doc.moveDown(0.5);

      // Metadata
      doc
        .font('Helvetica')
        .fontSize(10)
        .fillColor('#6b7280')
        .text(`Generated by LampScribe`, { align: 'center' });

      doc.text(`Date: ${new Date(transcript.createdAt).toLocaleDateString()}`, { align: 'center' });

      if (transcript.duration) {
        doc.text(`Duration: ${formatTimestamp(transcript.duration)}`, { align: 'center' });
      }

      doc.moveDown(2);

      // Horizontal line
      doc
        .strokeColor('#e5e7eb')
        .lineWidth(1)
        .moveTo(50, doc.y)
        .lineTo(545, doc.y)
        .stroke();

      doc.moveDown(1);

      // Content
      doc.font('Helvetica').fontSize(11).fillColor('#374151');

      if (transcript.segments && transcript.segments.length > 0 && options.includeTimestamps) {
        for (const segment of transcript.segments) {
          // Timestamp
          doc
            .font('Helvetica-Bold')
            .fontSize(9)
            .fillColor('#f59e0b')
            .text(`[${formatTimestamp(segment.startTime)}]`, { continued: true });

          // Speaker
          if (options.includeSpeakers && segment.speaker) {
            doc
              .font('Helvetica-Bold')
              .fontSize(11)
              .fillColor('#1f2937')
              .text(` ${segment.speaker}: `, { continued: true });
          }

          // Text
          doc
            .font('Helvetica')
            .fontSize(11)
            .fillColor('#374151')
            .text(segment.text);

          doc.moveDown(0.5);
        }
      } else {
        // Simple text content
        const paragraphs = transcript.text.split('\n\n');
        for (const paragraph of paragraphs) {
          doc.text(paragraph.trim(), {
            align: 'left',
            lineGap: 4,
          });
          doc.moveDown(0.8);
        }
      }

      // Footer
      const pageCount = doc.bufferedPageRange().count;
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(i);
        doc
          .font('Helvetica')
          .fontSize(8)
          .fillColor('#9ca3af')
          .text(
            `Page ${i + 1} of ${pageCount}`,
            50,
            doc.page.height - 30,
            { align: 'center', width: doc.page.width - 100 }
          );
      }

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Generate DOCX document
 */
export async function generateDocx(transcript: TranscriptData, options: ExportOptions = {}): Promise<Buffer> {
  const children: Paragraph[] = [];

  // Title
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: options.title || transcript.name,
          bold: true,
          size: 48, // 24pt
          color: '1f2937',
        }),
      ],
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 },
    })
  );

  // Metadata
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by LampScribe`,
          size: 20,
          color: '6b7280',
        }),
      ],
      alignment: AlignmentType.CENTER,
    })
  );

  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Date: ${new Date(transcript.createdAt).toLocaleDateString()}`,
          size: 20,
          color: '6b7280',
        }),
      ],
      alignment: AlignmentType.CENTER,
    })
  );

  if (transcript.duration) {
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `Duration: ${formatTimestamp(transcript.duration)}`,
            size: 20,
            color: '6b7280',
          }),
        ],
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
      })
    );
  }

  // Spacer
  children.push(new Paragraph({ spacing: { after: 200 } }));

  // Content
  if (transcript.segments && transcript.segments.length > 0 && options.includeTimestamps) {
    for (const segment of transcript.segments) {
      const runs: TextRun[] = [];

      // Timestamp
      runs.push(
        new TextRun({
          text: `[${formatTimestamp(segment.startTime)}] `,
          bold: true,
          size: 18,
          color: 'f59e0b',
        })
      );

      // Speaker
      if (options.includeSpeakers && segment.speaker) {
        runs.push(
          new TextRun({
            text: `${segment.speaker}: `,
            bold: true,
            size: 22,
            color: '1f2937',
          })
        );
      }

      // Text
      runs.push(
        new TextRun({
          text: segment.text,
          size: 22,
          color: '374151',
        })
      );

      children.push(
        new Paragraph({
          children: runs,
          spacing: { after: 160 },
        })
      );
    }
  } else {
    // Simple text content
    const paragraphs = transcript.text.split('\n\n');
    for (const paragraph of paragraphs) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: paragraph.trim(),
              size: 22,
              color: '374151',
            }),
          ],
          spacing: { after: 200, line: 320 },
        })
      );
    }
  }

  const doc = new Document({
    sections: [
      {
        properties: {},
        children,
      },
    ],
  });

  return await Packer.toBuffer(doc);
}

